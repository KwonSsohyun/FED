// 파일럿 PJ 메인 JS - main.js

////////////////////////////// 제이쿼리 로드구역 ///////////////////////////////////////////////
$(function () { ////////////// jQB (제이쿼리 코드블록) ///////////////////////////////////////////


    // 모바일일때 메인페이지 등장액션 클래스 지우기
    if(mob) $(".act").removeClass("act");
    // mob는 autoScroll.js 에서 모바일일때 1을 넣어줌

    ///////////////////////////////////////
    // 상단메뉴 클릭시 페이지 이동하기 
    ///////////////////////////////////////
    // 대상 : .gnb a
    $(".gnb a").click(function (e) {

        // 1. 기본이동막기
        e.preventDefault();

        // 2. 클릭된 a의 부모 li순번 알아내기
        //    유의사항 : 첫번째 li가 안보이도록 있어서 페이지 순번과 정확히 일치함!
        let idx = $(this).parent().index();
        console.log("순번:"+idx);

        // 중요!
        // pno에 idx 넣기!
        pno = idx;


        /* 코드가져옴 : FED\007.파일럿PJ\002.구현소스\js >> "autoScroll.js" */
        //////////////////////////////////////////////
        // 3. 이동할 페이지(.page)의 위치값 알아내기 ///
        //////////////////////////////////////////////

        ////////////////////////////////////////////////////
        // 새로운 페이지 위치값 : 윈도우 높이값 * 페이지순번 //
        let pos = $(window).height() * pno;
        ///////////////////////////////////////////////////

        //console.log("이동위치:" + pos);

        //////////////////////////////////////////////
        // 4. 실제 이동위치로 스크롤 애니메이션 하기 ////
        //////////////////////////////////////////////

        $("html,body").stop().animate({
            scrollTop: pos + "px"
        }, 1200, "easeOutQuint");

        // animate 콜백함수 아닌 바깥에서 호출하면
        // 페이지액션이 출발과 동시에 작동된다!
        // ex) }, 1200, "easeOutQuint"); -> 위 콜백함수로 하면 좀 나타나는게 느림
        //     페이지와 동시에 보이게 하려면 콜백함수가 아닌 밖에 호출한다.
        pageAction();
        /* 
            , pageAction ▶ 함수 호출한거임
            호출한 원본은 
            ▶ FED\007.파일럿PJ\002.구현소스\js >> "main.js" 
               맨 아래 있음
        */


        ///////////////////////////////////////////////
        // 5. 페이지번호(pno)에 맞는 GNB 메뉴 변경하기 //
        ///////////////////////////////////////////////
        // 변경대상: .gnb li, .indic li
        $(".gnb li").eq(pno).addClass("on")
            .siblings().removeClass("on");
        $(".indic li").eq(pno).addClass("on")
            .siblings().removeClass("on");
        // 선택된 li 이외의 li형제들 class="on"제거하기







    }); ///////// click //////////




    ///////////////////////////////////////
    /// 배너 드래그 기능 구현하기
    ///////////////////////////////////////
    // 드래그 대상 : .slide
    let slide = $(".slide");

    // 드래그 기능주기 -> 제이쿼리 UI 기능!
    slide.draggable({
        axis: "x" /// x축 고정 (X축가로 로만 이동함)
    }); /// draggable /////

    /*  
        [ 배너 드래그 이동의 기준 ]
          1. 현재 슬라이드의 left:-100% 값을 기준으로 판단함

          2. 오른쪽에서 들어오는 이동 
             -> left : -110% 보다 작을때

          3. 왼쪽에서 들어오는 이동
             -> left : -90% 보다 클때

          4. 제자리로 돌아가는 이동
             -> left가 -110% 보다 크고, -90% 작을때

          -> 구현상 유의사항
             : 실제로 이동시엔 px단위로 이동함 
               따라서 %를 px로 변환해 줘야한다!

               ex) 가로크기 : 1000px 
                   -> left : -100% === -1000px
                   
                   left : -110% -> left : -(1000 x 1.1) + "px" 
                   left : -90% -> left : -(1000 x 0.9) + "px" 
    */
    /* 
        [ 위의 설명 >> 배너 드래그 풀이 ]
          1. "index.html" 를 보면
              배너영역인
              <ul class="slide"> 
                <li class="ban6"><span class="ir">배너6</span></li>
                <li class="ban1"><span class="ir">배너1</span></li>
                <li class="ban2"><span class="ir">배너2</span></li>
                ....

             ▶ 배너 6번 슬라이드가 맨 먼저 있고, > 배너1 > 배너2 순으로 
                총 6개의 이미지 슬라이드가 있는걸 볼 수 있다.

                여기서 왜 6번 슬라이드가 왜 앞에 있지?
                이 메인배너는 좌우로 왔다갔다 드래그를 하며 움직일 수 있는 배너기능이 있다.
                그러니 첫슬이드가 완전 처음에 있다고 하면
                왼쪽에는 아무것도 없으니 왔다갔다 할 수 없으니 6번 슬라이드를 맨앞에 놓았다.

         2. 6번슬라이드가 맨앞에 있으니
            처음에 홈페이지에서 보일때는 배너1번 이미지부터 보여야하니
            "main.css" 에서
             슬라이드 박스 설정을 해준다.

             ▶ .slide{
                    position: absolute;
                    left: -100%;
                    ...
                }
                ▶ left: -100%; 를 줘서 
                   6번 슬라이드가 화면에서 안보이고, 
                   1번 이미지가 맨 처음 보이는걸 볼 수 있다.

                + left: -500% 하면 맨 뒤이미지가 보인다.
                  왜냐? 보이는 화면의 100%니까 하나의 이미지당 100%

         3. 시작점은 "배너6" 이다.
            시작점이니 배너6이 다 보이면 ▶ left값은 0%
            배너1이 화면에 다 보이면 ▶ left값은 -100%
            배너2이 화면에 다 보이면 ▶ left값은 -200%

            ▶ 이 수치가 왜 중요하냐면?
               : 왼쪽으로 슬라이드로 드레그 하거나, 
                 오른쪽 방향으로 드래그 했을때
                 일정 수치 이상으로 넘어가면 다음장 이미지 보여주고,
                 일정 수치 이하이면 안넘어가고 현재 이미지 유지를
                 하기 위해서다.

         4. 일정 수치를 잡자.
            자! 위에서 말했듯이 기준점은 0이다.(첫 위치에 있는 6번이미지)
            이미지는 6번이미지 ~ 5번이미지까지 통으로 붙어있다. (css에서 플랙스함)
            그걸 쉽게 생각해서 

            ▶ 통으로 잡고 "왼쪽" 으로 밀면 >> 왼쪽에 이미지들을 화면에서 넘기면 볼 수 있고, (-마이너스의 숫자가 작아짐)
            ▶ 통으로 잡고 "오른쪽" 으로 밀면 >> 오른쪽에 이미지들을 화면에서 계속 넘기면 볼 수 있고, (-마이너스의 숫자가 커짐)
            
            ----------------------------------------------------------------------------------------------------------

            ◆ left : -90% >> 6번이미지가 화면의 왼쪽으로 10%만 조금 보이고
            ◆ left : -110% >> 2번이미지가 화면의 오른쪽으로 10%만 조금 보인다.

            ▶ 이 일정수치를 기준으로 이동을 제어한다.
               ex) -90%의 수치보다 커지면 >> 6번슬라이드인 left=0% 으로 첫슬라이드 보이게 하고,
                   -110% 수치보다 작아지면 >> 2번슬라이드인 left=-200% 으로 이동한다.
                   -110% < 범위 < -90%  >>  현재슬라이드인 제자리로 이동


         5. 실제로 이동시엔 px단위로 이동해서 %를 px로 변환해줘야함
            ▶ -100% === 1000px 로 같다. 

            ▶ left : -110% ->> left : -(1000 x 1.1) + "px" 
            ▶ left : -90% ->> left : -(1000 x 0.9) + "px" 

            ▶ (앞으로 소숫점 두자리 이동)
                ex) (spos < -win * 1.1)  : -110% 구하기(앞으로 소숫점 두자리 이동) -> -win*1.1
                    (spos > -win * 0.9) : -90% 구하기(앞으로 소숫점 두자리 이동) -> -win*0.9

            ▷ -90% = -900px
            ▷ -110% = -1100px
    */



    // 윈도우 가로크기 구하는 함수
    let awin = () => $(window).width();
    /// awin 함수 ///
    /* 
        let awin = () => {
            return $(window).width();
        };
        ====================================
        let awin = () => $(window).width();

        ▶ 둘이 같은거임 > return을 쓸경우 {} 생략
        ====================================

        ▶ 화살표 뒤에 중괄호 {} 없이 
           명령문 하나만 있으면
           그게 바로 return 문이다! 
           
        ▶▶ 함수 호출한 곳으로 가져감!

           ▷ 참고자료 : JS005_ArrowFn.html
    */

    // 윈도우 가로크기
    let win = awin(); /* awin() -> 위에서 리턴값이 여기로 온다.(awin의 리턴값을 변수에 담는다.) */

    // 화면크기변경(resize)시 윈도우 가로크기 업데이트! 
    $(window).resize(() => {
        win = awin() /* 변수 재할당 */
        // console.log("윈도우가로:" + win);
    }); ///// resize ////////
    /* 
        [ 코드리뷰 ]
          1) $(window).resize -> 화면크기 변경시 -> 펑셩실행
          2) awin() -> 원래 awin에 설정한 $(window).width(); 가로크기만 구하는 함수에서 
                    -> 화면폭이 작아질때마다 가로크기값을 구해옴 
                    -> 값이 갱신됨
          3) win = awin() -> 변수 재할당 
    */
    /* 
        resize() 메서드
        : 화면크기가 변경될 떄 
    */




    // 현재 슬라이드 위치값 구하기
    // 슬라이드 위치값
    let spos;

    // 이징변수
    let easing = "easeOutQuint";

    // 화면커버(광드래그막기)
    let cover = $(".cover");

    // 슬라이드 순번 변수
    let sno = 0; // 첫슬라이드는 0번 (블릿li 순번도 0번부터!)

    // 블릿요소
    let indic = $(".bindic li");

    // 슬라이드 개수 
    let scnt = slide.find("li").length;
    // console.log("슬라이드갯수:"+scnt); -> 6개 찍힘
    /* 
        ▶ 이렇게 하는 이유는 슬라이드 갯수가 아무리 늘어놔도 갯수로 조정하기 위함
           ex) if(sno===6) sno = 0; -> 6일때 첫번호로! (항상 슬라이드 개수바뀔때마다 변경X > 비효율적)

               [ 이게 더 관리하기 편함 ]
                 ▶ if(sno===scnt) sno = 0; -> 슬라이드 수와 같아지면 첫 번호로! 
                 ▶ if(sno===-1) sno = scnt-1; -> -1이되면 마지막 번호로! (슬라이드개수 -1)
    */




    // 자동넘김 지우기 (맨 아래서 설정함)
    slide.on("dragstart", () => {
        clearAuto();
    });
    /* 아래에 있는 slide.on("dragstop" 안에 넣으면 안됨
       왜냐하면 드래그를 천천히 넘기면,
       이럴때 자동 넘김이 되기때문에 넣으면 알아서 넘겨지기 때문에
       여기에 넣기는 애매하다.

       ▶ 사용자가 드래그 스타트 하는 부분에 넣어줘야 완벽하다.
          : 자동넘김지우기는 드래그시작이벤트(dragstart) 에서
            해줘야 미리 끊어줄 수 있다~!

       외부함수면 함수자리에 호출할 수 있게 해줬다. (앗! on에서는 안되서 걍 다시 적음)
       ▷ slide.on("dragstart", function () { ▷ 이것이 아닌,
       ▶ slide.on("dragstart",clearAuto);  ▷ 이것이 안됨
          ▶ setInterval, setTimeout 은 됨
             .on에서 안된다는것
       ex)
       let aaa = () => {alert("나야나");};
       slide.click(aaa); 
       ▶ slide.click(aaa); ▷ 변수 넣어도 잘 나옴! 클릭하면 나야나 나옴!
          그니까 .click은 되는데 .on 이 안되는것임
    */



    // 대상 : .slide -> slide 변수
    // 이벤트 : dragstop -> 드래그가 끝났을때 (drag로만 하면 계속 값이 바뀌니, 드래그 멈췄을때만 값 나오게 하기)
    slide.on("dragstop", function () { // 슬라이드를 드래그해서 클릭 놓는 순간 펑셩 들어옴


        // 자동넘기기 지우기
        clearAuto();
        /* 안정감을 위해서 여기서도 같이 줬다. 
           위에서 사용자가 드래그를 첫 시작하는 동작을 할때도
           클리어오토를 했지만
           드래그를 하고 스탑했을때도 어쨌든 사용자가 건든거니까
           이때도 자동넘기기 지우기를 같이 해준다.
           정교한 코딩
        */


        // 광드래그 막기 커버보이기
        cover.show();
        /* 드래그해서 다음 슬라이드 넘기면 보임 
           - 맨처음에는 보이고 "main.css" 에 설정되어있음
             이게 뭐냐면 투명색인 메인배너 영역만큼의 빈박스가 드래그 안되게 막고 있음.

           이제 이게 계속 드래그도 안되게 막고 있으면 안되니,
           각각 이동후 지우게 처리한다.
           - if, else if, else 콜백함수 안에 넣는다. ->> cover.hide(); 
        */


        // 슬라이드 위치값 구하기
        spos = slide.offset().left; /* 내가 슬라이드 드래그해서 놓은 그 위치값 알아내는 것임 */
        // .offset().left ▶ 화면 왼쪽기준선 left위치

        console.log("슬라이드위치:" + spos);


        ////////////////////////// 이동구현하기 ////////////////////
        //  1. 오른쪽에서 들어오는 이동 
        //     : 슬라이드 left값이 -110% 보다 작을때
        //       -110% 구하기(앞으로 소숫점 두자리 이동) -> -win*1.1
        if (spos < -win * 1.1) {

            // 슬라이드가 -200% 위치로 이동한다!
            /* 
                stop() 메서드는 animate가 큐에 쌓이는 것을 막는다! (그래서 막 넘기면 손 놓으면 막 넘어가는걸 방지함) 
                stop() === 기본값인 stop(false,false) -> 시작하다가 마지막애니로 종료!

                ▷ 참고 : FED\004.jQuery학습\001.기본사용법\002.선택자메서드연습\jQuery-02.메서드연습 >> 48.animate_stop.html
            */
            slide.stop().animate({
                /* stop() 이제 막 넘기면, 처음값으로 돌아가니까 현재이미지가 펄쩍펄쩍 뜀  */
                left: -win * 2 + "px"
            }, 600, easing, function () { // easeOutQuint 이징값 // function(){ 콜백함수 (이동후 함수진행)

                // 변경대상 : .slide -> slide 변수
                slide
                    /* 첫번째 슬라이드 li를 맨뒤로 보내기 (ex) 6번이미지 맨 뒤로 보내기 - 계속 슬라이드 오른쪽으로 이동하면 맨앞이미지가 계속 뒤로 html 이동됨)
                    맨 앞에 있는걸 뒤로 보낸다. 근데 여기까지만하면 오른쪽으로 넘기면 탁 팅긴다. */
                    .append(slide.find("li").first())
                    /* 이때 left값을 -100% 위치로 고정해야한다! 

                       현재 left -200% 이기에 
                       2번 슬라이드 이미지가 화면에 보이는데,
                       그러면 슬라이드 순번이 
                       6 >> 1 >> 2(화면에 보임 -200%) >> 3 인데
                       6번이 맨 뒤로 가니, 맨 앞이 사라지니,
                       6번이 맨 앞을 지키고 있었을때가 -200%인데 
                       6번이 맨앞에 사라지고, 맨 뒤 슬라이드로 이동되니
                       
                       이제 슬라이드 순번이
                       1 >> 2(화면에 보임) >> 3 >>
                       당연히 -200% 이아니라 조정이 되야함
                       left : -100% 로 말이다. 
                       한마디로 경계선을 조정해준것!
                    */
                    .css({
                        left: -win + "px"
                    });
                /* 그러면 이제 오른쪽 슬라이드 계속 이동하면 팅기는것없이 잘나온다. */


                // 광드래그 커버지우기
                cover.hide(); /* 각각 이동후 지움 */

                // 배너글자 등장함수 호출!
                showTxt();
                // 아랫쪽의 sno변경이 먼저 이루어짐!


            }); /////// animate ///////


            // 블릿순번변경하기 : 오른쪽이동은 증가 (슬라이드 넘어가기 전에 바껴야하니까 콜백밖!)
            sno++;
            // 한계수 : 슬라이드 수와 같아지면 첫 번호로!
            if (sno === scnt) sno = 0; /* 6일때 0로 보낸다. */

            // 블릿변경함수 호출
            chgIndic();


        } ///// if문 : -110% 보다 작을때 ////////



        ////////////////////////// 이동구현하기 ////////////////////
        //  2. 왼쪽에서 들어오는 이동 
        //     : 슬라이드 left값이 -90% 보다 클때
        //       -90% 구하기(앞으로 소숫점 두자리 이동) -> -win*0.9
        else if (spos > -win * 0.9) {

            // 슬라이드가 0 위치로 이동한다!
            slide.stop().animate({
                left: "0px"
            }, 600, easing, function () { // 콜백함수 (이동후 함수진행)

                // 대상 : .slide -> slide 변수
                slide
                    /* 맨뒤의 슬라이드 li를 맨 앞으로 이동해줌 
                       이걸 함으로써 이제 왼쪽으로 슬라이드 이동하면 계속 맨 앞으로 이미지 생성되는걸 볼수 있다. (앞쪽으로 슬라이드가 추가되는걸 볼 수 있음) 
                       근데 팅겨서 보이니 css 원래처럼 -100% 로 아래서 변경해줌 */
                    .prepend(slide.find("li").last())
                    // left값을 원래 위치인 -100%로 변경
                    .css({
                        left: -win + "px"
                    });
                /* 그러면 이제 왼쪽 슬라이드 계속 이동하면 팅기는것없이 잘나온다. */

                // 광드래그 커버지우기
                cover.hide(); /* 각각 이동후 지움 */

                // 배너글자 등장함수 호출!
                showTxt();
                // 아랫쪽의 sno변경이 먼저 이루어짐!


            }); /////// animate ///////


            // 블릿순번변경하기 : 왼쪽이동은 감소! (슬라이드 넘어가기 전에 바껴야하니까 콜백밖!)
            sno--;
            // 한계수 : -1이되면 마지막 번호로! (슬라이드개수 -1)
            if (sno === -1) sno = scnt - 1;

            // 블릿변경함수 호출
            chgIndic();


        } ///// else if문 : -90% 보다 클때 ////////



        /// 3. 사이범위 일때 제자리로 돌아오기
        //     -110% < 범위 < -90%
        else {
            // 슬라이드가 원위치로 돌아옴!
            slide.stop().animate({
                left: -win + "px"
            }, 300, easing, function () { // 콜백함수 (이동후)

                // 광드래그 커버 지우기
                cover.hide(); /* 각각 이동후 지움 */

            }); /////// animate ///////

        } ///////// else문 : 사이범위 //////


    }); /////////// dragstop ///////////////////////////
    ///////////////////////////////////////////////



    // 블릿변경함수 (전역함수)
    let chgIndic = () => {

        // 블릿변경하기 : .bindic li -> indic 변수 
        indic.eq(sno).addClass("on")
            .siblings().removeClass("on");
        /* 해당 번호일때 클래스 on하고, 나머지들은 클래스 on 지워라 */

        /* 
            변경될때만 실행하라해서 -> 엄밀한 코드
            제자리일때는 해당이 안되게 하기 위해서
            if , else if 일때만
            ▶ 블릿변경함수 호출 한다!  
            ▶ chgIndic();
        */
        // console.log("블릿순번:"+sno);

    }; ///// chgIndic /////



    // 배너등장 텍스트
    let banTxt = [
        "Men's Season <br> Collection",
        "2021 Special <br> Collection",
        "GongYoo <br> Collection",
        "T-Shirt <br> Collection",
        "Shoes <br> Collection",
        "Wind Jacket <br> Collection"
    ];



    /////////////////// 배너글자 등장 함수 /////////////////////////////
    //////////////////////////////////////////////////////////////////
    let showTxt = () => {

        // console.log("슬라이드순번:"+sno);

        // 0. 있을 수 있는 .btit박스 지우기!
        $(".btit").remove();

        // 1. 배너글자 박스넣기
        //    대상 : .slide li -> 항상 두번째 슬라이드임! 왜냐하면 위에서보면 앞에 하나있고, 2번째 있는거에 글자가 나오는것 (계속 잘려나가고 뒤로가고 하니까)
        slide.find("li").eq(1)
            .append('<h2 class="btit"></h2>'); /* 추가함 -> 클래스 btit 생성! */


        // 배너화면 구성상 왼쪽과 오른쪽으로 글자위치 조정
        // sno순번상  >>  1번슬라이드와, 2번슬라이드 이미지만 오른쪽 배치
        //                left value 즉, left값을 변수로 처리!
        let lval = "30%"; // 왼쪽 설정값
        if (sno === 1 || sno === 2) lval = "70%"; // 1,2번 슬라이드 이미지일때 > 오른쪽 설정값 (값 덮어쓰는 방식)


        // 2. 배너글자 박스 CSS -> 위에 새로생성한 btit 바로 쓴다.
        $(".btit") // 주인공이 css 넣고, html도 바꾸겠다. , 애니메이션도 추가 (왜냐? 점을 써서 계속 연결함)
            .css({

                position: "absolute",
                top: "55%", // 살짝 내림 (위에서 아래로 글자보이게 처리하려고) > 아래쪽으로 살짝 내려감!(올라올예정!)
                left: lval, // 변수로 처리(오른쪽, 왼쪽 구분)
                transform: "translate(-50%,-50%)",
                font: "bold 4.5vmax Verdana",
                /* CSS > "015.뷰포트단위" : 가로세로중에 큰걸 기준한다. >> 가로세로를 기준한 큰거의 화면의 4.5% */
                color: "#fff",
                textShadow: "1px 1px 3px #777",
                whiteSpace: "nowrap",
                /* 줄바꿈안됨 */
                opacity: 0 // 투명도 (단위가 들어가면 따옴표로 싸야하는데, 숫자만 들어가면 안싸도됨) (문자형/숫자형 모두가능)

            }) ///// css /////

            // 3. 글자넣기 - 주인공에서 이어짐!(왜냐? 점을 써서 계속 연결함)
            .html(banTxt[sno]) /* 위에서 banTxt 배열내용 sno순번에 맡게 들어감 */

            /* 
                배너글자 등장함수 호출! (배너 이미지나오고 글자등장)
                showTxt();
                if , else if문 콜백함수 안에 넣음 + 첫 슬라이드에도 글자 나오게 최초후출 맨 아래에다가 한다.
            */

            // 4. 애니메이션 등장하기 - 주인공에서 이어짐!(왜냐? 점을 써서 계속 연결함)
            .animate({
                top: "50%",
                opacity: 1
            }, 1000, "easeInOutQuart"); /* 함수이징 : easeInOutQuart 붙혀넣음 */


    }; ///////////// showTxt 함수 ///////////////////////
    ////////////////////////////////////////////////////


    // 배너텍스트 등장함수 최초호출!
    showTxt(); // 첫번째 슬라이드도 글자 보이게 하기 위함



    /***********************************************************/
    /// 배너 자동넘기기 함수 : 오른쪽에서 들어옴! //////////////////
    /***********************************************************/
    let goSlide = () => {

        // 광드래그 막기 커버보이기
        cover.show();
        /* 위에서 if함수내용만 가져온거라 이것도 cover.show해야해서
           여기에는 cover.show가 없어서 똑같이 이것도 가져온거임
           아래서 광드래그 방지하기 위한 코드 쓰기 위함 > cover.hide() */

        /*************** if 함수 안에 있는거 그대로 복사해서 가져옴 ***************/
        // 슬라이드가 -200% 위치로 이동한다!
        slide.stop().animate({
            /* stop() 이제 막 넘기면, 처음값으로 돌아가니까 현재이미지가 펄쩍펄쩍 뜀  */
            left: -win * 2 + "px"
        }, 600, easing, function () { // easeOutQuint 이징값 // function(){ 콜백함수 (이동후 함수진행)

            // 변경대상 : .slide -> slide 변수
            slide
                .append(slide.find("li").first())
                .css({
                    left: -win + "px"
                });
            /* 그러면 이제 오른쪽 슬라이드 계속 이동하면 팅기는것없이 잘나온다. */

            // 광드래그 커버지우기
            cover.hide(); /* 각각 이동후 지움 */

            // 배너글자 등장함수 호출!
            showTxt();
            // 아랫쪽의 sno변경이 먼저 이루어짐!


        }); /////// animate ///////


        // 블릿순번변경하기 : 오른쪽이동은 증가 (슬라이드 넘어가기 전에 바껴야하니까 콜백밖!)
        sno++;
        // 한계수 : 슬라이드 수와 같아지면 첫 번호로!
        if (sno === scnt) sno = 0; /* 6일때 0로 보낸다. */

        // 블릿변경함수 호출
        chgIndic();

    }; ///////////// goSlide 함수 ////////////////////
    /////////////////////////////////////////////////



    // 인터발용 변수 <지우기용>
    let autoI; // 인터발용 I

    // 타임아웃용 변수 <지우기용>
    let autoT; // 타임아웃용 T



    /***********************************************************/
    /// 자동인터발호출 함수 //////////////////////////////////////
    /***********************************************************/
    let autoSlide = () => {

        autoI = setInterval(goSlide, 2500); /* 2.5초간격으로 goSlide 함수를 호출하게 해줌 */
        /* 넘기는 값만 없으면, 함수명만 할 수 있게 해줬다. */

    }; ///// autoSlide 함수 ///////////////////////
    //////////////////////////////////////////////


    // 인터발 최초호출!
    autoSlide();
    /* 할당이 이순간되므로, 위에서 만드로 바로 호출~ */
    /* ->> 확인해보면 2.5초간격으로 계속 오른쪽으로 슬라이드 이동 */


    /***********************************************************/
    /// 인터발지우기 함수 + 안건들면 다시 호출 /////////////////////
    /***********************************************************/
    let clearAuto = () => {

        // 1. 인터발 지우기
        clearInterval(autoI);

        // 2. 타임아웃지우기 (실행 쓰나미 방지!)
        clearTimeout(autoT);

        // 3. 일정시간 뒤 다시 인터발 호출!
        autoT = setTimeout(autoSlide, 3000);
        // 3초동안 기다렸다가 다시 인터발함수 호출!


        // ▷ 참조 : E:\MyGit\FED\004.jQuery학습\003.응용구현\Gurumi_PJ\js >> main.js


    }; ////////////// clearAuto 함수 //////////////


}); ///////////////////// jQB ////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////



/********************************************* 
    함수명 : pageAction
    기능 : 페이지 도착시 등장액션하기
    구현방법 : 클래스를 해당요소 주기!
    페이지구분 : pno 페이지번호 변수사용
    변경대상 : .page
*********************************************/
function pageAction() {

    // .page 중 순번에 맞게 선택 후 
    $(".page").eq(pno)
        // 자손중 .act를 찾아 클래스 "on"을 주시오!
        .find(".act").addClass("on");
    // .act가 여러개여도 클래스를 모두에게 줌~!
    // 제이쿼리 내부적으로 for문을 돌려줌!

    /* 호출은 스크롤한다음이니 
       ▶ FED\007.파일럿PJ\002.구현소스\js >> "autoScroll.js" 
       ▶ 4. 실제 이동위치로 스크롤 애니메이션 아래에 호출함 */

} //////// pageAction 함수 ///////////
////////////////////////////////////