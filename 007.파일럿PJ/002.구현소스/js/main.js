// 파일럿 PJ 메인 JS - main.js

////////////////////////////// 제이쿼리 로드구역 ///////////////////////////////////////////////
$(function () { ////////////// jQB (제이쿼리 코드블록) ///////////////////////////////////////////

    ///////////////////////////////////////
    /// 배너 드래그 기능 구현하기
    ///////////////////////////////////////
    // 드래그 대상 : .slide
    let slide = $(".slide");

    // 드래그 기능주기 -> 제이쿼리 UI 기능!
    slide.draggable({
        axis: "x" /// x축 고정 (X축가로 로만 이동함)
    }); /// draggable /////

    /* 
        [ 배너 드래그 이동의 기준 ]
          1. 현재 슬라이드의 left:-100% 값을 기준으로 판단함

          2. 오른쪽에서 들어오는 이동 
             -> left : -110% 보다 작을때

          3. 왼쪽에서 들어오는 이동
             -> left : -90% 보다 클때

          4. 제자리로 돌아가는 이동
             -> left가 -110% 보다 크고, -90% 작을때

          -> 구현상 유의사항
             : 실제로 이동시엔 px단위로 이동함 
               따라서 %를 px로 변환해 줘야한다!

               ex) 가로크기 : 1000px 
                   -> left : -100% === -1000px
                   
                   left : -110% -> left : -(1000 x 1.1) + "px" 
                   left : -90% -> left : -(1000 x 0.9) + "px" 
    */
    /* 
        [ 위의 설명 >> 배너 드래그 풀이 ]
          1. "index.html" 를 보면
              배너영역인
              <ul class="slide"> 
                <li class="ban6"><span class="ir">배너6</span></li>
                <li class="ban1"><span class="ir">배너1</span></li>
                <li class="ban2"><span class="ir">배너2</span></li>
                ....

             ▶ 배너 6번 슬라이드가 맨 먼저 있고, > 배너1 > 배너2 순으로 
                총 6개의 이미지 슬라이드가 있는걸 볼 수 있다.

                여기서 왜 6번 슬라이드가 왜 앞에 있지?
                이 메인배너는 좌우로 왔다갔다 드래그를 하며 움직일 수 있는 배너기능이 있다.
                그러니 첫슬이드가 완전 처음에 있다고 하면
                왼쪽에는 아무것도 없으니 왔다갔다 할 수 없으니 6번 슬라이드를 맨앞에 놓았다.

         2. 6번슬라이드가 맨앞에 있으니
            처음에 홈페이지에서 보일때는 배너1번 이미지부터 보여야하니
            "main.css" 에서
             슬라이드 박스 설정을 해준다.

             ▶ .slide{
                    position: absolute;
                    left: -100%;
                    ...
                }
                ▶ left: -100%; 를 줘서 
                   6번 슬라이드가 화면에서 안보이고, 
                   1번 이미지가 맨 처음 보이는걸 볼 수 있다.

                + left: -500% 하면 맨 뒤이미지가 보인다.
                  왜냐? 보이는 화면의 100%니까 하나의 이미지당 100%

         3. 시작점은 "배너6" 이다.
            시작점이니 배너6이 다 보이면 ▶ left값은 0%
            배너1이 화면에 다 보이면 ▶ left값은 -100%
            배너2이 화면에 다 보이면 ▶ left값은 -200%

            ▶ 이 수치가 왜 중요하냐면?
               : 왼쪽으로 슬라이드로 드레그 하거나, 
                 오른쪽 방향으로 드래그 했을때
                 일정 수치 이상으로 넘어가면 다음장 이미지 보여주고,
                 일정 수치 이하이면 안넘어가고 현재 이미지 유지를
                 하기 위해서다.

         4. 일정 수치를 잡자.
            자! 위에서 말했듯이 기준점은 0이다.(첫 위치에 있는 6번이미지)
            이미지는 6번이미지 ~ 5번이미지까지 통으로 붙어있다. (css에서 플랙스함)
            그걸 쉽게 생각해서 

            ▶ 통으로 잡고 "왼쪽" 으로 밀면 >> 왼쪽에 이미지들을 화면에서 넘기면 볼 수 있고, (-마이너스의 숫자가 작아짐)
            ▶ 통으로 잡고 "오른쪽" 으로 밀면 >> 오른쪽에 이미지들을 화면에서 계속 넘기면 볼 수 있고, (-마이너스의 숫자가 커짐)
            
            ----------------------------------------------------------------------------------------------------------

            ◆ left : -90% >> 6번이미지가 화면의 왼쪽으로 10%만 조금 보이고
            ◆ left : -110% >> 2번이미지가 화면의 오른쪽으로 10%만 조금 보인다.

            ▶ 이 일정수치를 기준으로 이동을 제어한다.
               ex) -90%의 수치보다 커지면 >> 6번슬라이드인 left=0% 으로 첫슬라이드 보이게 하고,
                   -110% 수치보다 작아지면 >> 2번슬라이드인 left=-200% 으로 이동한다.
                   -110% < 범위 < -90%  >>  현재슬라이드인 제자리로 이동


         5. 실제로 이동시엔 px단위로 이동해서 %를 px로 변환해줘야함
            ▶ -100% === 1000px 로 같다. 

            ▶ left : -110% ->> left : -(1000 x 1.1) + "px" 
            ▶ left : -90% ->> left : -(1000 x 0.9) + "px" 

            ▶ (앞으로 소숫점 두자리 이동)
                ex) (spos < -win * 1.1)  : -110% 구하기(앞으로 소숫점 두자리 이동) -> -win*1.1
                    (spos > -win * 0.9) : -90% 구하기(앞으로 소숫점 두자리 이동) -> -win*0.9

            ▷ -90% = -900px
            ▷ -110% = -1100px
    */



    // 윈도우 가로크기 구하는 함수
    let awin = () => $(window).width();
    /// awin 함수 ///
    /* 
        let awin = () => {
            return $(window).width();
        };
        ====================================
        let awin = () => $(window).width();

        ▶ 둘이 같은거임 > return을 쓸경우 {} 생략
        ====================================

        ▶ 화살표 뒤에 중괄호 {} 없이 
           명령문 하나만 있으면
           그게 바로 return 문이다! 
           
        ▶▶ 함수 호출한 곳으로 가져감!

           ▷ 참고자료 : JS005_ArrowFn.html
    */

    // 윈도우 가로크기
    let win = awin(); /* awin() -> 위에서 리턴값이 여기로 온다. */

    // 화면크기변경(resize)시 윈도우 가로크기 업데이트! 
    $(window).resize(() => {
        win = awin()  /* 변수 재할당 */
        // console.log("윈도우가로:" + win);
    }); ///// resize ////////
    /* 
        resize() 메서드
        : 화면크기가 변경될 떄 
    */




    // 현재 슬라이드 위치값 구하기
    // 슬라이드 위치값
    let spos;

    // 이징변수
    let easing = "easeOutQuint";

    // 화면커버(광드래그막기)
    let cover = $(".cover");

    // 슬라이드 순번 변수
    let sno = 0; // 첫슬라이드는 0번 (블릿li 순번도 0번부터!)

    // 블릿요소
    let indic = $(".bindic li");

    // 슬라이드 개수 
    let scnt = slide.find("li").length;
    // console.log("슬라이드갯수:"+scnt); -> 6개 찍힘
    /* 
        ▶ 이렇게 하는 이유는 슬라이드 갯수가 아무리 늘어놔도 갯수로 조정하기 위함
           ex) if(sno===6) sno = 0; -> 6일때 첫번호로! (항상 슬라이드 개수바뀔때마다 변경X > 비효율적)

               [ 이게 더 관리하기 편함 ]
                 ▶ if(sno===scnt) sno = 0; -> 슬라이드 수와 같아지면 첫 번호로! 
                 ▶ if(sno===-1) sno = scnt-1; -> -1이되면 마지막 번호로! (슬라이드개수 -1)
    */


                 
    // 대상 : .slide -> slide 변수
    // 이벤트 : dragstop -> 드래그가 끝났을때 (drag로만 하면 계속 값이 바뀌니, 드래그 멈췄을때만 값 나오게 하기)
    slide.on("dragstop", function () { // 슬라이드를 드래그해서 클릭 놓는 순간 펑셩 들어옴


        // 광드래그 막기 커버보이기
        cover.show(); 
        /* 드래그해서 다음 슬라이드 넘기면 보임 
           - 맨처음에는 보이고 main.css 에 설정되어있음

           이제 이게 계속 보이면 안되니,
           각각 이동후 지우게 처리한다.
           - if, else if, else 콜백함수 안에 넣는다. ->> cover.hide(); 
        */


        // 슬라이드 위치값 구하기
        spos = slide.offset().left; /* 내가 슬라이드 드래그해서 놓은 그 위치값 알아내는 것임 */
        // .offset().left ▶ 화면 왼쪽기준선 left위치

        console.log("슬라이드위치:" + spos);


        ////////////////////////// 이동구현하기 ////////////////////
        //  1. 오른쪽에서 들어오는 이동 
        //     : 슬라이드 left값이 -110% 보다 작을때
        //       -110% 구하기(앞으로 소숫점 두자리 이동) -> -win*1.1
        if (spos < -win * 1.1) {

            // 슬라이드가 -200% 위치로 이동한다!
            /* 
                stop() 메서드는 animate가 큐에 쌓이는 것을 막는다! (그래서 막 넘기면 손 놓으면 막 넘어가는걸 방지함) 
                stop() === 기본값인 stop(false,false) -> 시작하다가 마지막애니로 종료!

                ▷ 참고 : FED\004.jQuery학습\001.기본사용법\002.선택자메서드연습\jQuery-02.메서드연습 >> 48.animate_stop.html
            */
            slide.stop().animate({  /* stop() 이제 막 넘기면, 처음값으로 돌아가니까 현재이미지가 펄쩍펄쩍 뜀  */
                left: -win * 2 + "px"
            }, 600, easing , function(){ // easeOutQuint 이징값 // function(){ 콜백함수 (이동후 함수진행)
                
                // 변경대상 : .slide -> slide 변수
                slide
                /* 첫번째 슬라이드 li를 맨뒤로 보내기 (ex) 6번이미지 맨 뒤로 보내기 - 계속 슬라이드 오른쪽으로 이동하면 맨앞이미지가 계속 뒤로 html 이동됨)
                맨 앞에 있는걸 뒤로 보낸다. 근데 여기까지만하면 오른쪽으로 넘기면 탁 팅긴다. */
                .append(slide.find("li").first()) 
                /* 이때 left값을 -100% 위치로 고정해야한다! 

                   현재 left -200% 이기에 
                   2번 슬라이드 이미지가 화면에 보이는데,
                   그러면 슬라이드 순번이 
                   6 >> 1 >> 2(화면에 보임 -200%) >> 3 인데
                   6번이 맨 뒤로 가니, 맨 앞이 사라지니,
                   6번이 맨 앞을 지키고 있었을때가 -200%인데 
                   6번이 맨앞에 사라지고, 맨 뒤 슬라이드로 이동되니
                   
                   이제 슬라이드 순번이
                   1 >> 2(화면에 보임) >> 3 >>
                   당연히 -200% 이아니라 조정이 되야함
                   left : -100% 로 말이다. 
                   한마디로 경계선을 조정해준것!
                */
                .css({left:-win+"px"});
                /* 그러면 이제 오른쪽 슬라이드 계속 이동하면 팅기는것없이 잘나온다. */


                // 광드래그 커버지우기
                cover.hide(); /* 각각 이동후 지움 */


            }); /////// animate ///////


            // 블릿순번변경하기 : 오른쪽이동은 증가 (슬라이드 넘어가기 전에 바껴야하니까 콜백밖!)
            sno++;
            // 한계수 : 슬라이드 수와 같아지면 첫 번호로!
            if(sno===scnt) sno = 0; /* 6일때 0로 보낸다. */

            // 블릿변경함수 호출
            chgIndic();


        } ///// if문 : -110% 보다 작을때 ////////



        ////////////////////////// 이동구현하기 ////////////////////
        //  2. 왼쪽에서 들어오는 이동 
        //     : 슬라이드 left값이 -90% 보다 클때
        //       -90% 구하기(앞으로 소숫점 두자리 이동) -> -win*0.9
        else if (spos > -win * 0.9) {

            // 슬라이드가 0 위치로 이동한다!
            slide.stop().animate({ 
                left: "0px"
            }, 600, easing , function(){ // 콜백함수 (이동후 함수진행)

                // 대상 : .slide -> slide 변수
                slide
                /* 맨뒤의 슬라이드 li를 맨 앞으로 이동해줌 
                   이걸 함으로써 이제 왼쪽으로 슬라이드 이동하면 계속 맨 앞으로 이미지 생성되는걸 볼수 있다. (앞쪽으로 슬라이드가 추가되는걸 볼 수 있음) 
                   근데 팅겨서 보이니 css 원래처럼 -100% 로 아래서 변경해줌 */
                .prepend(slide.find("li").last())
                // left값을 원래 위치인 -100%로 변경
                .css({left:-win+"px"});
                /* 그러면 이제 왼쪽 슬라이드 계속 이동하면 팅기는것없이 잘나온다. */

                // 광드래그 커버지우기
                cover.hide(); /* 각각 이동후 지움 */

            }); /////// animate ///////


            // 블릿순번변경하기 : 왼쪽이동은 감소! (슬라이드 넘어가기 전에 바껴야하니까 콜백밖!)
            sno--;
            // 한계수 : -1이되면 마지막 번호로! (슬라이드개수 -1)
            if(sno===-1) sno = scnt-1;

            // 블릿변경함수 호출
            chgIndic();


        } ///// else if문 : -90% 보다 클때 ////////



        /// 3. 사이범위 일때 제자리로 돌아오기
        //     -110% < 범위 < -90%
        else {
            // 슬라이드가 원위치로 돌아옴!
            slide.stop().animate({
                left: -win + "px"
            }, 300, easing, function(){ // 콜백함수 (이동후)

                // 광드래그 커버 지우기
                cover.hide(); /* 각각 이동후 지움 */

            }); /////// animate ///////

        } ///////// else문 : 사이범위 //////

        
    }); /////////// dragstop ///////////////////////////
    ///////////////////////////////////////////////



    // 블릿변경함수 (전역함수)
    let chgIndic = () => {

        // 블릿변경하기 : .bindic li -> indic 변수 
            indic.eq(sno).addClass("on")
            .siblings().removeClass("on");
            /* 해당 번호일때 클래스 on하고, 나머지들은 클래스 on 지워라 */

            /* 
                변경될때만 실행하라해서 -> 엄밀한 코드
                제자리일때는 해당이 안되게 하기 위해서
                if , else if 일때만
                ▶ 블릿변경함수 호출 한다!  
                ▶ chgIndic();
            */
            // console.log("블릿순번:"+sno);

        }; ///// chgIndic /////



}); ///////////////////// jQB ////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////